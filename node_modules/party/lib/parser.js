
/*!
 * Party - MultipartParser
 * Copyright (c) 2010 LearnBoost <tj@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Stream = require('stream').Stream;

/**
 * Expose `MultipartParser`.
 */

module.exports = MultipartParser;

/**
 * Initialize a new `MultipartParser` with the given `boundary` string.
 *
 * @param {String} boundary
 * @param {Object} options
 * @api public
 */

function MultipartParser(boundary, options) {
  options = options || {};
  if ('string' != typeof boundary) throw new Error('boundary string required');
  boundary = '\r\n--' + boundary;
  this.writable = true;
  this.boundary = new Buffer(boundary);
  this.boundaryLen = boundary.length;
  this.scratch = new Buffer(boundary.length + 8);
  this.state = 'preamble';
  this.table = this.createBoundaryTable(boundary);
  this.index = 0;
  this.plugins = [];
}

/**
 * Inherit from `Stream.prototype`.
 */

MultipartParser.prototype.__proto__ = Stream.prototype;

/**
 * Use the given plugin `fn`.
 *
 * @param {Function} fn
 * @return {MultipartParser} for chaining
 * @api public
 */

MultipartParser.prototype.use = function(fn){
  this.plugins.push(fn);
  fn(this);
  return this;
};

/**
 * Create the `boundary` table.
 *
 * @param {String} boundary
 * @return {Object}
 * @api private
 */

MultipartParser.prototype.createBoundaryTable = function(boundary){
  var obj = {};
  for (var i = 0, len = boundary.length; i < len; ++i) {
    obj[boundary.charCodeAt(i)] = true;
  }
  return obj;
};

/**
 * Emit error `msg`.
 *
 * @param {String} msg
 * @api private
 */

MultipartParser.prototype.error = function(msg){
  this.emit('error', new Error(msg));
  this.parse = function(){};
};

/**
 * End parsing, checks the parse state.
 *
 * @api public
 */

MultipartParser.prototype.end = function(){
  if ('end' != this.state) {
    this.error('multipart parser end() called before parsing completed');
  }
};

/**
 * Parse the given `chunk`.
 *
 * @param {Buffer} chunk
 * @api public
 */

MultipartParser.prototype.parse =
MultipartParser.prototype.write = function(chunk){
  var len = chunk.length
    , boundary = this.boundary
    , btab = this.table
    , blen = this.boundaryLen
    , bend = this.boundaryLen - 1
    , scratch = this.scratch
    , index = this.index
    , prevIndex = index
    , state = this.state
    , type = ''
    , mark = 0
    , c;

  for (var i = 0; i < len; ++i) {
    c = chunk[i];
    // console.log(' %s : %s', state, String.fromCharCode(c));
    switch (state) {
      case 'preamble':
        // TODO: this is not to spec
        if (0x2d != c) break;
        state = 'initial boundary -';
        ++index;
        break;
      case 'initial boundary -':
        if (0x2d != c) return this.error('missing initial boundary --');
        state = 'initial boundary';
        ++index;
        break;
      case 'initial boundary':
        // done
        if (index > bend - 2) {
          state = 'initial boundary lws';
          index = 0;
          --i;
        // boundary char
        } else if (c == boundary[index + 2]) {
          ++index;
        // failed match
        } else {
          return this.error('char at ' + index + ' does not match boundary');
        }
        break;
      case 'initial boundary lws':
        // space or tab (linear whitespace)
        if (0x20 == c || 0x09 == c) continue;
        // CR
        if (0x0d == c) { state = 'initial boundary CR'; continue }
        return this.error('missing initial boundary CR');
        break;
      case 'initial boundary CR':
        if (0x0a != c) return this.error('missing initial boundary LF');
        state = 'part start';
        break;
      case 'part start':
        mark = i;
        state = 'part';
        this.emit('part start');
      case 'part':
        // TODO: LWS
        prevIndex = index;

        // skip non-boundary data
        if (0 == index) {
          while (i + blen <= len) {
            if (chunk[i + bend] in btab) break;
            i += blen;
          }
          c = chunk[i];
        }

        if (index < blen) {
          // maybe part of the boundary
          if (boundary[index] == c) {
            // potential new boundary
            // emit the previous part
            if (0 == index && mark != i) {
              this.emit('part data', chunk.slice(mark, i), mark, i);
            }
            ++index;
          // not part of the boundary
          } else {
            index = 0;
          }
        } else if (index == blen) {
          ++index;
          // CR
          if (0x0d == c) {
            type = 'part';
          // -
          } else if (0x2d == c) {
            type = 'end';
          }
        } else if (index == blen + 1) {
          if ('part' == type) {
            index = 0;
            // LF
            if (0x0a == c) {
              state = 'part start';
              break;
            }
          } else if ('end' == type) {
            // -
            if (0x2d == c) {
              state = 'end';
              this.emit('end');
            } else {
              index = 0;
            }
          } else {
            index = 0;
          }
        }

        // scratch buffer so we can
        // emit this as "part data" on
        // a failed match
        if (index) {
          scratch[index - 1] = c;
        } else if (prevIndex) {
          this.emit('part data', scratch.slice(0, prevIndex), 0, prevIndex);
          prevIndex = 0;
          mark = i--;
        }
        break;
    }
  }

  // TODO: remove min()
  if (!index) this.emit('part data', chunk.slice(mark, Math.min(i, len)), mark, i);
  this.index = index;
  this.state = state;
};